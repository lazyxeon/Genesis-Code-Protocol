name: Complete Release Process

# This workflow orchestrates the complete release process including bundling and signing
on:
  release:
    types: [published]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  # First job: Create and upload bundle artifacts
  create-bundle:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      release-tag: ${{ steps.setup.outputs.release-tag }}
      bundle-created: ${{ steps.upload.outputs.bundle-created }}
    env:
      RELEASE_TAG: ${{ github.ref_name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup release info
        id: setup
        run: |
          set -euo pipefail
          echo "release-tag=$RELEASE_TAG" >> "$GITHUB_OUTPUT"
          echo "Creating bundle for release: $RELEASE_TAG"

      # Prepare a staging directory and create a ZIP of selected folders
      - name: Prepare staging
        run: |
          set -euo pipefail
          rm -rf dist
          mkdir -p dist
          echo "Creating release bundle for tag: $RELEASE_TAG"
          if [ ! -d "cli_bundle" ] || [ ! -d "Documents" ] || [ ! -d "scripts" ]; then
            echo "Error: Required directories (cli_bundle, Documents, scripts) not found"
            exit 1
          fi
          zip -r "dist/GCP_${RELEASE_TAG}_Field_Kit.zip" "cli_bundle" "Documents" "scripts" \
            -x "*.git*" "*.github*"
          echo "Bundle created: GCP_${RELEASE_TAG}_Field_Kit.zip"
          ls -la dist/

      # Generate SPDX SBOM for the bundled artifact
      - name: SBOM (SPDX)
        uses: anchore/sbom-action@v0
        with:
          path: dist/GCP_${{ env.RELEASE_TAG }}_Field_Kit.zip
          format: spdx-json
          output-file: dist/sbom.spdx.json

      # Generate CycloneDX SBOM for the bundled artifact
      - name: SBOM (CycloneDX)
        uses: anchore/sbom-action@v0
        with:
          path: dist/GCP_${{ env.RELEASE_TAG }}_Field_Kit.zip
          format: cyclonedx-json
          output-file: dist/sbom.cdx.json

      # Create a SHA-256 checksum file for all artifacts
      - name: SHA-256 checksums
        run: |
          set -euo pipefail
          cd dist
          if [ -z "$(ls -A 2>/dev/null)" ]; then
            echo "Error: No files found in dist directory"
            exit 1
          fi
          echo "Creating checksums for:"
          ls -la
          sha256sum * > SHA256SUMS.txt
          echo "Checksums created:"
          cat SHA256SUMS.txt

      # Upload the ZIP and SBOM files to the GitHub release
      - name: Upload bundle to release
        id: upload
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          files: |
            dist/GCP_${{ github.ref_name }}_Field_Kit.zip
            dist/sbom.spdx.json
            dist/sbom.cdx.json
            dist/SHA256SUMS.txt

      - name: Signal bundle created
        id: complete
        run: |
          set -euo pipefail
          echo "bundle-created=true" >> "$GITHUB_OUTPUT"
          echo "Bundle creation completed successfully"

  # Second job: Sign all release artifacts
  sign-artifacts:
    needs: create-bundle
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    env:
      RELEASE_TAG: ${{ needs.create-bundle.outputs.release-tag }}
      REPO: ${{ github.repository }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Install Cosign at a pinned commit
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: 'v2.5.3'

      # Download all assets attached to the release
      - name: Download release artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          mkdir -p signed_artifacts
          echo "Downloading assets for release: $RELEASE_TAG"
          
          # Retry logic for downloading artifacts
          max_attempts=5
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "Download attempt $attempt of $max_attempts"
            if gh release download "$RELEASE_TAG" --repo "$REPO" --dir signed_artifacts; then
              break
            elif [ $attempt -eq $max_attempts ]; then
              echo "Error: Failed to download release assets after $max_attempts attempts"
              exit 1
            else
              echo "Download failed, waiting 30 seconds before retry..."
              sleep 30
              ((attempt++))
            fi
          done
          
          # Remove any existing signature files to avoid conflicts
          find signed_artifacts -name "*.sigstore" -delete || true
          find signed_artifacts -name "*.sig" -delete || true
          
          # Verify we have assets to sign
          if [ -z "$(ls -A signed_artifacts)" ]; then
            echo "Error: No assets found to sign"
            exit 1
          fi
          echo "Found assets to sign:"
          ls -la signed_artifacts

      # Sign each downloaded artifact using cosign
      - name: Sign release artifacts
        env:
          COSIGN_EXPERIMENTAL: '1'
        run: |
          set -euo pipefail
          cd signed_artifacts
          
          # Create signing directory
          mkdir -p signatures
          
          for file in *; do
            [ -f "$file" ] || continue
            [[ "$file" == *.sigstore ]] && continue
            [[ "$file" == *.sig ]] && continue
            [[ "$file" == signatures ]] && continue
            
            echo "Signing $file..."
            
            # Sign with Sigstore (includes transparency log entry)
            cosign sign-blob --yes --bundle "signatures/$file.sigstore" "$file"
            
            # Generate traditional signature for compatibility
            cosign sign-blob --yes --output-signature "signatures/$file.sig" "$file"
            
            echo "✓ Signed $file"
          done
          
          echo "Signing completed. Generated signatures:"
          ls -la signatures/

      # Verify signatures and transparency log entries
      - name: Verify signatures
        env:
          COSIGN_EXPERIMENTAL: '1'
        run: |
          set -euo pipefail
          cd signed_artifacts
          
          echo "Verifying signatures and transparency log entries..."
          verification_failed=false
          
          for file in *; do
            [ -f "$file" ] || continue
            [[ "$file" == *.sigstore ]] && continue
            [[ "$file" == *.sig ]] && continue
            [[ "$file" == signatures ]] && continue
            
            if [ -f "signatures/$file.sigstore" ]; then
              echo "Verifying $file..."
              if cosign verify-blob --bundle "signatures/$file.sigstore" "$file"; then
                echo "✓ Verification successful for $file"
              else
                echo "✗ Verification failed for $file"
                verification_failed=true
              fi
            else
              echo "✗ No signature bundle found for $file"
              verification_failed=true
            fi
          done
          
          if [ "$verification_failed" = true ]; then
            echo "Error: Signature verification failed for one or more files"
            exit 1
          fi
          
          echo "All signatures verified successfully!"

      # Upload signatures to the release
      - name: Upload signatures to release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          cd signed_artifacts
          
          # Verify we have signature files to upload
          if [ -z "$(ls signatures/*.sigstore 2>/dev/null || true)" ] && [ -z "$(ls signatures/*.sig 2>/dev/null || true)" ]; then
            echo "Error: No signature files found to upload"
            exit 1
          fi
          
          echo "Uploading signature files:"
          ls -la signatures/
          
          # Upload all signature files to the release
          gh release upload "$RELEASE_TAG" signatures/* --repo "$REPO" --clobber
          
          echo "All signatures uploaded successfully!"

      # Create signing summary
      - name: Create signing summary
        run: |
          set -euo pipefail
          cd signed_artifacts
          
          echo "# Release Signing Summary" > ../SIGNING_SUMMARY.md
          echo "" >> ../SIGNING_SUMMARY.md
          echo "Release: \`$RELEASE_TAG\`" >> ../SIGNING_SUMMARY.md
          echo "Repository: \`$REPO\`" >> ../SIGNING_SUMMARY.md
          echo "Signed at: \`$(date -u)\`" >> ../SIGNING_SUMMARY.md
          echo "" >> ../SIGNING_SUMMARY.md
          echo "## Signed Artifacts" >> ../SIGNING_SUMMARY.md
          echo "" >> ../SIGNING_SUMMARY.md
          
          for file in *; do
            [ -f "$file" ] || continue
            [[ "$file" == *.sigstore ]] && continue
            [[ "$file" == *.sig ]] && continue
            [[ "$file" == signatures ]] && continue
            
            echo "- \`$file\`" >> ../SIGNING_SUMMARY.md
            if [ -f "signatures/$file.sigstore" ]; then
              echo "  - Sigstore bundle: ✅" >> ../SIGNING_SUMMARY.md
            fi
            if [ -f "signatures/$file.sig" ]; then
              echo "  - Traditional signature: ✅" >> ../SIGNING_SUMMARY.md
            fi
          done
          
          echo "" >> ../SIGNING_SUMMARY.md
          echo "All artifacts are signed with Sigstore (keyless signing) and include transparency log entries." >> ../SIGNING_SUMMARY.md
          
          echo "Generated signing summary:"
          cat ../SIGNING_SUMMARY.md

      # Upload signing summary
      - name: Upload signing summary
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release upload "$RELEASE_TAG" SIGNING_SUMMARY.md --repo "$REPO" --clobber