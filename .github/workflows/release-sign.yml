name: Sign Release Artifacts

# Trigger when a release is published (i.e. created and marked as published)
on:
  release:
    types: [published]
  workflow_dispatch:

# Default permissions are read-only
permissions:
  contents: read

jobs:
  sign-release:
    if: github.event_name == 'release' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    # The job needs write access to upload the signed artifacts, and
    # id-token to authenticate with Sigstore for keyless signing
    permissions:
      contents: write
      id-token: write
    env:
      # Provide the tag name and repository for gh commands
      RELEASE_TAG: ${{ github.event.release.tag_name || github.ref_name }}
      REPO: ${{ github.repository }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Install Cosign at a pinned commit; cosign-release specifies the cosign version
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: 'v2.5.3'

      # Download all assets attached to the release. gh CLI is preinstalled on
      # GitHub-hosted runners. We authenticate using GH_TOKEN (alias of GITHUB_TOKEN).
      - name: Download release artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          mkdir -p signed_artifacts
          echo "Downloading assets for release: $RELEASE_TAG"
          # Download every asset from the published release
          if ! gh release download "$RELEASE_TAG" --repo "$REPO" --dir signed_artifacts; then
            echo "Error: Failed to download release assets"
            exit 1
          fi
          # Remove any existing signature bundles to avoid re-uploading them
          find signed_artifacts -name "*.sigstore" -delete
          # Verify we have assets to sign
          if [ -z "$(ls -A signed_artifacts)" ]; then
            echo "Error: No assets found to sign"
            exit 1
          fi
          echo "Found assets to sign:"
          ls -la signed_artifacts

      # Sign each downloaded artifact using cosign's keyless signing.  The
      # resulting .sigstore bundles contain the signature and certificate.
      - name: Sign release artifacts
        env:
          COSIGN_EXPERIMENTAL: '1'
        run: |
          set -euo pipefail
          cd signed_artifacts
          for file in *; do
            [ -f "$file" ] || continue
            [[ "$file" == *.sigstore ]] && continue
            echo "Signing $file..."
            cosign sign-blob --yes --bundle "$file.sigstore" "$file"
          done

      # Upload the signature bundles back to the same release
      - name: Upload signatures to release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          cd signed_artifacts
          # Verify we have signature files to upload
          if [ -z "$(ls *.sigstore 2>/dev/null)" ]; then
            echo "Error: No signature files found to upload"
            exit 1
          fi
          echo "Uploading signature files:"
          ls -la *.sigstore
          # Upload all .sigstore files to the release.  --clobber overwrites if the
          # asset already exists (idempotent).
          gh release upload "$RELEASE_TAG" *.sigstore --repo "$REPO" --clobber
