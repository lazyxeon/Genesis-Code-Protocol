name: Validate Jupyter Notebooks

on:
  push:
    branches: [ "main" ]
    paths:
      - "**/*.ipynb"
      - ".github/workflows/validate-notebooks.yml"
  pull_request:
    paths:
      - "**/*.ipynb"
      - ".github/workflows/validate-notebooks.yml"
  workflow_dispatch: {}
  schedule:
    - cron: "11 4 * * *"   # optional: nightly check

permissions:
  contents: read

concurrency:
  group: nb-validate
  cancel-in-progress: true

jobs:
  validate:
    runs-on: ubuntu-latest
    env:
      # --- Tunables ---
      NB_TIMEOUT_SECS: "600"          # per-notebook execution timeout
      NB_EXECUTE: "true"              # set "false" to only validate JSON structure
      NB_DIRS: "Notebooks\nExamples"  # scanned top-level dirs (one per line)
      EXCLUDE_GLOBS: |
        **/.ipynb_checkpoints/**
        **/*[skip-ci]*.ipynb
        **/*[manual]*.ipynb
        **/*[heavy]*.ipynb
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install notebook deps
        run: |
          python -m pip install --upgrade pip
          pip install nbformat nbclient jupyter

      - name: Validate / execute notebooks (inline)
        run: |
          python - <<'PY'
          from __future__ import annotations
          import os, sys, glob, json
          from pathlib import Path
          import nbformat
          from nbclient import NotebookClient, CellExecutionError

          ROOT = Path(".").resolve()
          timeout = int(os.getenv("NB_TIMEOUT_SECS","600"))
          do_exec = os.getenv("NB_EXECUTE","true").lower() == "true"

          # Collect directories to scan (existing ones only)
          nb_dirs = [line.strip() for line in os.getenv("NB_DIRS","Notebooks").splitlines() if line.strip()]
          scan_dirs = [d for d in nb_dirs if (ROOT / d).is_dir()]
          if not scan_dirs:
            scan_dirs = ["."]
          # Build file list
          paths = set()
          for d in scan_dirs:
            paths.update(glob.glob(str(ROOT / d / "**/*.ipynb"), recursive=True))

          # Apply exclude globs
          exclude = [line.strip() for line in os.getenv("EXCLUDE_GLOBS","").splitlines() if line.strip()]
          def excluded(p: Path)->bool:
            s = p.as_posix()
            import fnmatch
            return any(fnmatch.fnmatch(s, g) for g in exclude)

          # Helpers to decide skipping
          def meta_skip(nb)->bool:
            # skip if top-level metadata marks it
            if isinstance(nb.metadata, dict):
              # option 1: metadata.ci.skip = true
              ci = nb.metadata.get("ci", {})
              if isinstance(ci, dict) and ci.get("skip") is True:
                return True
              # option 2: metadata.tags contains "skip_ci"
              tags = nb.metadata.get("tags", [])
              if isinstance(tags, list) and any(t.lower()=="skip_ci" for t in tags if isinstance(t,str)):
                return True
            # option 3: any cell tagged "skip_ci"
            for cell in nb.cells:
              if "metadata" in cell and isinstance(cell["metadata"], dict):
                t = cell["metadata"].get("tags", [])
                if isinstance(t, list) and any(str(x).lower()=="skip_ci" for x in t):
                  return True
            return False

          nb_files = sorted(Path(p) for p in paths if Path(p).is_file() and not excluded(Path(p)))
          if not nb_files:
            print("No notebooks found to validate.")
            sys.exit(0)

          failures = []
          print(f"Discovered {len(nb_files)} notebook(s):")
          for p in nb_files:
            print(f"::group::Validating {p}")
            try:
              nb = nbformat.read(p, as_version=4)
            except Exception as e:
              print(f"::error file={p}::Failed to parse as notebook: {e}")
              failures.append((p, f"parse error: {e}"))
              print("::endgroup::")
              continue

            # filename-based skip flag
            fname = p.name.lower()
            file_skip = ("[skip-ci]" in fname) or ("[manual]" in fname) or ("[heavy]" in fname)
            if file_skip or meta_skip(nb):
              print(f"Skipping (marked skip): {p}")
              print("::endgroup::")
              continue

            if not do_exec:
              print("Parsed OK (execution disabled).")
              print("::endgroup::")
              continue

            try:
              client = NotebookClient(nb, timeout=timeout, kernel_name="python3", allow_errors=False)
              client.execute()
              print("âœ… Executed OK")
            except CellExecutionError as e:
              print(f"::error file={p}::Execution failed: {e}")
              failures.append((p, f"exec error: {e}"))
            except Exception as e:
              print(f"::error file={p}::Unexpected failure: {e}")
              failures.append((p, f"unexpected: {e}"))
            finally:
              print("::endgroup::")

          if failures:
            print("\nFailed notebooks:")
            for p, why in failures:
              print(f" - {p}: {why}")
            sys.exit(1)
          else:
            print("All notebooks validated successfully.")
          PY
