name: Markdownlint

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Pre-normalize Markdown in workspace for lint
        run: |
          python - <<'PY'
          import re, os
          from pathlib import Path

          root = Path(".")

          # ---------- helpers ----------
          def is_blank(s: str) -> bool:
              return s.strip() == ""

          HEADING_RE = re.compile(r'^(#{1,6})\s+\S')
          LIST_RE    = re.compile(r'^(\s*)([-*+]|[0-9]+\.)\s+')
          FENCE_RE   = re.compile(r'^\s*```')

          def ensure_trailing_newline(text: str) -> str:
              return text if text.endswith("\n") else text + "\n"

          def normalize_changelog(p: Path, text: str) -> str:
              # Make sure first non-blank line is a single top-level H1 "Changelog"
              lines = text.splitlines(keepends=True)

              # Find first non-blank line
              idx = 0
              while idx < len(lines) and is_blank(lines[idx]):
                  idx += 1

              # Detect if we already have an H1 anywhere
              h1_positions = [i for i, l in enumerate(lines) if l.startswith("# ")]

              # If first non-blank not H1, prepend a single '# Changelog'
              if idx == len(lines) or not lines[idx].startswith("# "):
                  lines = ["# Changelog\n", "\n"] + lines

              # Demote any subsequent duplicate '# Changelog' to '## Changelog'
              first = True
              for i, l in enumerate(lines):
                  if l.strip().lower().startswith("# changelog"):
                      if first:
                          # ensure it's exactly one '# ' (H1)
                          lines[i] = "# Changelog\n"
                          first = False
                      else:
                          lines[i] = "## Changelog\n"

              # Normalize spacing for MD022/MD032 in CHANGELOG only
              out, in_code = [], False
              i, n = 0, len(lines)
              while i < n:
                  line = lines[i]
                  if FENCE_RE.match(line):
                      out.append(line)
                      in_code = not in_code
                      i += 1
                      continue
                  if not in_code and HEADING_RE.match(line):
                      if len(out) > 0 and not is_blank(out[-1]):
                          out.append("\n")
                      out.append(line)
                      nxt = lines[i+1] if i+1 < n else ""
                      if not is_blank(nxt):
                          out.append("\n")
                      i += 1
                      continue
                  if not in_code and LIST_RE.match(line):
                      # if previous non-blank isn't a list, add blank line before
                      prev_nonblank = next((out[j] for j in range(len(out)-1, -1, -1) if not is_blank(out[j])), None)
                      if prev_nonblank is None or not LIST_RE.match(prev_nonblank):
                          if len(out) > 0 and not is_blank(out[-1]):
                              out.append("\n")
                      # emit contiguous list block
                      while i < n and LIST_RE.match(lines[i]) and not FENCE_RE.match(lines[i]):
                          out.append(lines[i]); i += 1
                      nxt = lines[i] if i < n else ""
                      if not is_blank(nxt):
                          out.append("\n")
                      continue
                  out.append(line); i += 1

              # Collapse multiple blanks to one (MD012)
              compact = []
              for l in out:
                  if not (len(compact) >= 1 and compact[-1] == "\n" and l == "\n"):
                      compact.append(l)

              return "".join(compact)

          def normalize_fences_and_trailing_newline(p: Path, text: str) -> str:
              # Insert a blank line before/after fenced blocks (MD031)
              lines = text.splitlines(keepends=True)
              out = []
              i, n = 0, len(lines)
              in_code = False
              while i < n:
                  line = lines[i]
                  if FENCE_RE.match(line):
                      # ensure blank line before (unless start or already blank)
                      if len(out) > 0 and not is_blank(out[-1]):
                          out.append("\n")
                      out.append(line)
                      in_code = not in_code
                      # lookahead to ensure blank line after when fence closes
                      if not in_code:
                          nxt = lines[i+1] if i+1 < n else ""
                          if not is_blank(nxt):
                              out.append("\n")
                      i += 1
                      continue
                  out.append(line)
                  i += 1

              s = "".join(out)
              return ensure_trailing_newline(s)

          for p in root.rglob("*.md"):
              try:
                  txt = p.read_text(encoding="utf-8")
              except Exception:
                  continue

              original = txt
              if p.name == "CHANGELOG.md":
                  txt = normalize_changelog(p, txt)
              # For all markdown files: fix fences + trailing newline
              txt = normalize_fences_and_trailing_newline(p, txt)

              if txt != original:
                  p.write_text(txt, encoding="utf-8")
                  print(f"Prepared {p}")
          PY

      - name: Run markdownlint-cli2
        uses: DavidAnson/markdownlint-cli2-action@v19.1.0
        with:
          globs: |
            **/*.md
            #node_modules
