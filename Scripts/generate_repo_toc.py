#!/usr/bin/env python3
"""
generate_repo_toc.py

Scans the repository for README.md files and top-level directories and generates
a simple markdown Table of Contents (REPO_TOC.md) linking to each README.

Usage:
    python Scripts/generate_repo_toc.py
    python Scripts/generate_repo_toc.py --root /path/to/repo --output REPO_TOC.md

This script is intentionally defensive and easy to copy/paste.
"""

from __future__ import annotations
import argparse
import os
from pathlib import Path
from typing import List


IGNORED_DIRS = {".git", ".venv", "venv", "__pycache__", ".github", "node_modules"}


def find_top_level_items(root: Path) -> List[Path]:
    """Return top-level directories and files we might want to include in the TOC."""
    items: List[Path] = []
    for p in sorted(root.iterdir()):
        if p.name in IGNORED_DIRS:
            continue
        # Include directories and top-level README.md or README files
        if p.is_dir():
            items.append(p)
        elif p.is_file() and p.name.lower().startswith("readme"):
            items.append(p)
    return items


def readme_for_dir(dir_path: Path) -> Path | None:
    """Return README path inside a directory if present, prefer README.md."""
    candidates = ["README.md", "README.rst", "README.txt", "README"]
    for c in candidates:
        cand = dir_path / c
        if cand.exists():
            return cand
    return None


def make_link(path: Path, root: Path) -> str:
    """Generate a relative link for markdown from path to root."""
    try:
        rel = path.relative_to(root)
    except Exception:
        rel = path
    return str(rel).replace(os.path.sep, "/")


def generate_toc(root: Path) -> str:
    """Create a markdown TOC string for the repository rooted at `root`."""
    lines: List[str] = []
    lines.append("# Repository Table of Contents")
    lines.append("")
    top_items = find_top_level_items(root)

    # If top-level README exists, put it first
    top_readmes = [p for p in top_items if p.is_file() and p.name.lower().startswith("readme")]
    if top_readmes:
        for r in top_readmes:
            lines.append(f"- [{r.name}]({make_link(r, root)})")
        lines.append("")

    # Directories and their READMEs
    for item in top_items:
        if item.is_dir():
            readme = readme_for_dir(item)
            if readme:
                lines.append(f"- [{item.name}]({make_link(readme, root)})")
            else:
                # link to directory (use trailing slash to hint folder)
                lines.append(f"- {item.name}/")
    lines.append("")
    lines.append("_Generated by Scripts/generate_repo_toc.py_")
    return "\n".join(lines)


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate a repository Table of Contents")
    parser.add_argument(
        "--root", "-r", type=Path, default=Path.cwd(), help="Repository root directory (default: cwd)"
    )
    parser.add_argument(
        "--output", "-o", type=Path, default=Path("REPO_TOC.md"), help="Output markdown file"
    )
    args = parser.parse_args()

    root = args.root.resolve()
    if not root.exists() or not root.is_dir():
        print(f"Error: root path {root} does not exist or is not a directory.")
        return 2

    toc = generate_toc(root)
    try:
        args.output.write_text(toc, encoding="utf-8")
        print(f"Wrote TOC to {args.output}")
    except Exception as exc:
        print(f"Failed to write {args.output}: {exc}")
        return 3

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
